// Code generated by protoc-gen-gogo.
// source: common/model.proto
// DO NOT EDIT!

/*
	Package common is a generated protocol buffer package.

	It is generated from these files:
		common/model.proto

	It has these top-level messages:
		University
		Subject
		Course
		Section
		Meeting
		Instructor
		Book
		Metadata
		Registration
		Semester
*/
package common

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.GoGoProtoPackageIsVersion1

type Season int32

const (
	Season_fall   Season = 0
	Season_spring Season = 1
	Season_summer Season = 2
	Season_winter Season = 3
)

var Season_name = map[int32]string{
	0: "fall",
	1: "spring",
	2: "summer",
	3: "winter",
}
var Season_value = map[string]int32{
	"fall":   0,
	"spring": 1,
	"summer": 2,
	"winter": 3,
}

func (x Season) Enum() *Season {
	p := new(Season)
	*p = x
	return p
}
func (x Season) String() string {
	return proto.EnumName(Season_name, int32(x))
}
func (x *Season) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Season_value, data, "Season")
	if err != nil {
		return err
	}
	*x = Season(value)
	return nil
}
func (Season) EnumDescriptor() ([]byte, []int) { return fileDescriptorModel, []int{0} }

type University struct {
	Id                 int64          `protobuf:"varint,1,opt,name=id" json:"id" db:"id"`
	Name               string         `protobuf:"bytes,2,opt,name=name" json:"name" db:"name"`
	Abbr               string         `protobuf:"bytes,3,opt,name=abbr" json:"abbr" db:"abbr"`
	HomePage           string         `protobuf:"bytes,4,opt,name=home_page,json=homePage" json:"home_page" db:"home_page"`
	RegistrationPage   string         `protobuf:"bytes,5,opt,name=registration_page,json=registrationPage" json:"registration_page" db:"registration_page"`
	MainColor          string         `protobuf:"bytes,6,opt,name=main_color,json=mainColor" json:"main_color" db:"main_color"`
	AccentColor        string         `protobuf:"bytes,7,opt,name=accent_color,json=accentColor" json:"accent_color" db:"accent_color"`
	TopicName          string         `protobuf:"bytes,8,opt,name=topic_name,json=topicName" json:"topic_name" db:"topic_name"`
	Subjects           []Subject      `protobuf:"bytes,9,rep,name=subjects" json:"subjects"`
	AvailableSemesters []Semester     `protobuf:"bytes,10,rep,name=available_semesters,json=availableSemesters" json:"available_semesters"`
	Registrations      []Registration `protobuf:"bytes,11,rep,name=registrations" json:"registrations"`
	Metadata           []Metadata     `protobuf:"bytes,12,rep,name=metadata" json:"metadata"`
	XXX_unrecognized   []byte         `json:"-"`
}

func (m *University) Reset()                    { *m = University{} }
func (m *University) String() string            { return proto.CompactTextString(m) }
func (*University) ProtoMessage()               {}
func (*University) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{0} }

func (m *University) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *University) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *University) GetAbbr() string {
	if m != nil {
		return m.Abbr
	}
	return ""
}

func (m *University) GetHomePage() string {
	if m != nil {
		return m.HomePage
	}
	return ""
}

func (m *University) GetRegistrationPage() string {
	if m != nil {
		return m.RegistrationPage
	}
	return ""
}

func (m *University) GetMainColor() string {
	if m != nil {
		return m.MainColor
	}
	return ""
}

func (m *University) GetAccentColor() string {
	if m != nil {
		return m.AccentColor
	}
	return ""
}

func (m *University) GetTopicName() string {
	if m != nil {
		return m.TopicName
	}
	return ""
}

func (m *University) GetSubjects() []Subject {
	if m != nil {
		return m.Subjects
	}
	return nil
}

func (m *University) GetAvailableSemesters() []Semester {
	if m != nil {
		return m.AvailableSemesters
	}
	return nil
}

func (m *University) GetRegistrations() []Registration {
	if m != nil {
		return m.Registrations
	}
	return nil
}

func (m *University) GetMetadata() []Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type Subject struct {
	Id               int64      `protobuf:"varint,1,opt,name=id" json:"id" db:"id"`
	UniversityId     int64      `protobuf:"varint,2,opt,name=university_id,json=universityId" json:"university_id" db:"university_id"`
	Name             string     `protobuf:"bytes,3,opt,name=name" json:"name" db:"name"`
	Number           string     `protobuf:"bytes,4,opt,name=number" json:"number" db:"number"`
	Season           string     `protobuf:"bytes,5,opt,name=season" json:"season" db:"season"`
	Year             string     `protobuf:"bytes,6,opt,name=year" json:"year" db:"year"`
	Hash             string     `protobuf:"bytes,7,opt,name=hash" json:"hash" db:"hash"`
	TopicName        string     `protobuf:"bytes,8,opt,name=topic_name,json=topicName" json:"topic_name" db:"topic_name"`
	Courses          []Course   `protobuf:"bytes,9,rep,name=courses" json:"courses"`
	Metadata         []Metadata `protobuf:"bytes,10,rep,name=metadata" json:"metadata"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *Subject) Reset()                    { *m = Subject{} }
func (m *Subject) String() string            { return proto.CompactTextString(m) }
func (*Subject) ProtoMessage()               {}
func (*Subject) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{1} }

func (m *Subject) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Subject) GetUniversityId() int64 {
	if m != nil {
		return m.UniversityId
	}
	return 0
}

func (m *Subject) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Subject) GetNumber() string {
	if m != nil {
		return m.Number
	}
	return ""
}

func (m *Subject) GetSeason() string {
	if m != nil {
		return m.Season
	}
	return ""
}

func (m *Subject) GetYear() string {
	if m != nil {
		return m.Year
	}
	return ""
}

func (m *Subject) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *Subject) GetTopicName() string {
	if m != nil {
		return m.TopicName
	}
	return ""
}

func (m *Subject) GetCourses() []Course {
	if m != nil {
		return m.Courses
	}
	return nil
}

func (m *Subject) GetMetadata() []Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type Course struct {
	Id               int64      `protobuf:"varint,1,opt,name=id" json:"id" db:"id"`
	SubjectId        int64      `protobuf:"varint,2,opt,name=subject_id,json=subjectId" json:"subject_id" db:"subject_id"`
	Name             string     `protobuf:"bytes,3,opt,name=name" json:"name" db:"name"`
	Number           string     `protobuf:"bytes,4,opt,name=number" json:"number" db:"number"`
	Synopsis         *string    `protobuf:"bytes,5,opt,name=synopsis" json:"synopsis,omitempty" db:"synopsis"`
	Hash             string     `protobuf:"bytes,6,opt,name=hash" json:"hash" db:"hash"`
	TopicName        string     `protobuf:"bytes,7,opt,name=topic_name,json=topicName" json:"topic_name" db:"topic_name"`
	Sections         []Section  `protobuf:"bytes,9,rep,name=sections" json:"sections"`
	Metadata         []Metadata `protobuf:"bytes,10,rep,name=metadata" json:"metadata"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *Course) Reset()                    { *m = Course{} }
func (m *Course) String() string            { return proto.CompactTextString(m) }
func (*Course) ProtoMessage()               {}
func (*Course) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{2} }

func (m *Course) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Course) GetSubjectId() int64 {
	if m != nil {
		return m.SubjectId
	}
	return 0
}

func (m *Course) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Course) GetNumber() string {
	if m != nil {
		return m.Number
	}
	return ""
}

func (m *Course) GetSynopsis() string {
	if m != nil && m.Synopsis != nil {
		return *m.Synopsis
	}
	return ""
}

func (m *Course) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *Course) GetTopicName() string {
	if m != nil {
		return m.TopicName
	}
	return ""
}

func (m *Course) GetSections() []Section {
	if m != nil {
		return m.Sections
	}
	return nil
}

func (m *Course) GetMetadata() []Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type Section struct {
	Id               int64        `protobuf:"varint,1,opt,name=id" json:"id" db:"id"`
	CourseId         int64        `protobuf:"varint,2,opt,name=course_id,json=courseId" json:"course_id" db:"course_id"`
	Number           string       `protobuf:"bytes,3,opt,name=number" json:"number" db:"number"`
	CallNumber       string       `protobuf:"bytes,4,opt,name=call_number,json=callNumber" json:"call_number" db:"call_number"`
	Max              int64        `protobuf:"varint,5,opt,name=max" json:"max" db:"max"`
	Now              int64        `protobuf:"varint,6,opt,name=now" json:"now" db:"now"`
	Status           string       `protobuf:"bytes,7,opt,name=status" json:"status" db:"status"`
	Credits          string       `protobuf:"bytes,8,opt,name=credits" json:"credits" db:"credits"`
	TopicName        string       `protobuf:"bytes,9,opt,name=topic_name,json=topicName" json:"topic_name" db:"topic_name"`
	Meetings         []Meeting    `protobuf:"bytes,10,rep,name=meetings" json:"meetings"`
	Instructors      []Instructor `protobuf:"bytes,11,rep,name=instructors" json:"instructors"`
	Books            []Book       `protobuf:"bytes,12,rep,name=books" json:"books"`
	Metadata         []Metadata   `protobuf:"bytes,13,rep,name=metadata" json:"metadata"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *Section) Reset()                    { *m = Section{} }
func (m *Section) String() string            { return proto.CompactTextString(m) }
func (*Section) ProtoMessage()               {}
func (*Section) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{3} }

func (m *Section) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Section) GetCourseId() int64 {
	if m != nil {
		return m.CourseId
	}
	return 0
}

func (m *Section) GetNumber() string {
	if m != nil {
		return m.Number
	}
	return ""
}

func (m *Section) GetCallNumber() string {
	if m != nil {
		return m.CallNumber
	}
	return ""
}

func (m *Section) GetMax() int64 {
	if m != nil {
		return m.Max
	}
	return 0
}

func (m *Section) GetNow() int64 {
	if m != nil {
		return m.Now
	}
	return 0
}

func (m *Section) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Section) GetCredits() string {
	if m != nil {
		return m.Credits
	}
	return ""
}

func (m *Section) GetTopicName() string {
	if m != nil {
		return m.TopicName
	}
	return ""
}

func (m *Section) GetMeetings() []Meeting {
	if m != nil {
		return m.Meetings
	}
	return nil
}

func (m *Section) GetInstructors() []Instructor {
	if m != nil {
		return m.Instructors
	}
	return nil
}

func (m *Section) GetBooks() []Book {
	if m != nil {
		return m.Books
	}
	return nil
}

func (m *Section) GetMetadata() []Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type Meeting struct {
	Id               int64      `protobuf:"varint,1,opt,name=id" json:"id" db:"id"`
	SectionId        int64      `protobuf:"varint,2,opt,name=section_id,json=sectionId" json:"section_id" db:"section_id"`
	Room             *string    `protobuf:"bytes,3,opt,name=room" json:"room,omitempty" db:"room"`
	Day              *string    `protobuf:"bytes,4,opt,name=day" json:"day,omitempty" db:"day"`
	StartTime        string     `protobuf:"bytes,5,opt,name=start_time,json=startTime" json:"start_time" db:"start_time"`
	EndTime          string     `protobuf:"bytes,6,opt,name=end_time,json=endTime" json:"end_time" db:"end_time"`
	Index            string     `protobuf:"bytes,7,opt,name=index" json:"index" db:"index"`
	Metadata         []Metadata `protobuf:"bytes,8,rep,name=metadata" json:"metadata"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *Meeting) Reset()                    { *m = Meeting{} }
func (m *Meeting) String() string            { return proto.CompactTextString(m) }
func (*Meeting) ProtoMessage()               {}
func (*Meeting) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{4} }

func (m *Meeting) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Meeting) GetSectionId() int64 {
	if m != nil {
		return m.SectionId
	}
	return 0
}

func (m *Meeting) GetRoom() string {
	if m != nil && m.Room != nil {
		return *m.Room
	}
	return ""
}

func (m *Meeting) GetDay() string {
	if m != nil && m.Day != nil {
		return *m.Day
	}
	return ""
}

func (m *Meeting) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *Meeting) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *Meeting) GetIndex() string {
	if m != nil {
		return m.Index
	}
	return ""
}

func (m *Meeting) GetMetadata() []Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type Instructor struct {
	Id               int64  `protobuf:"varint,1,opt,name=id" json:"id" db:"id"`
	SectionId        int64  `protobuf:"varint,2,opt,name=section_id,json=sectionId" json:"section_id" db:"section_id"`
	Name             string `protobuf:"bytes,3,opt,name=name" json:"name" db:"name"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Instructor) Reset()                    { *m = Instructor{} }
func (m *Instructor) String() string            { return proto.CompactTextString(m) }
func (*Instructor) ProtoMessage()               {}
func (*Instructor) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{5} }

func (m *Instructor) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Instructor) GetSectionId() int64 {
	if m != nil {
		return m.SectionId
	}
	return 0
}

func (m *Instructor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Book struct {
	Id               int64  `protobuf:"varint,1,opt,name=id" json:"id" db:"id"`
	SectionId        int64  `protobuf:"varint,2,opt,name=section_id,json=sectionId" json:"section_id" db:"section_id"`
	Title            string `protobuf:"bytes,3,opt,name=title" json:"title" db:"title"`
	Url              string `protobuf:"bytes,4,opt,name=url" json:"url" db:"url"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Book) Reset()                    { *m = Book{} }
func (m *Book) String() string            { return proto.CompactTextString(m) }
func (*Book) ProtoMessage()               {}
func (*Book) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{6} }

func (m *Book) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Book) GetSectionId() int64 {
	if m != nil {
		return m.SectionId
	}
	return 0
}

func (m *Book) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Book) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

type Metadata struct {
	Id               int64  `protobuf:"varint,1,opt,name=id" json:"id" db:"id"`
	UniversityId     int64  `protobuf:"varint,2,opt,name=university_id,json=universityId" json:"university_id" db:"university_id"`
	SubjectId        int64  `protobuf:"varint,3,opt,name=subject_id,json=subjectId" json:"subject_id" db:"subject_id"`
	CourseId         int64  `protobuf:"varint,4,opt,name=course_id,json=courseId" json:"course_id" db:"course_id"`
	SectionId        int64  `protobuf:"varint,5,opt,name=section_id,json=sectionId" json:"section_id" db:"section_id"`
	MeetingId        int64  `protobuf:"varint,6,opt,name=meeting_id,json=meetingId" json:"meeting_id" db:"meeting_id"`
	Title            string `protobuf:"bytes,7,opt,name=title" json:"title" db:"title"`
	Content          string `protobuf:"bytes,8,opt,name=content" json:"content" db:"content"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Metadata) Reset()                    { *m = Metadata{} }
func (m *Metadata) String() string            { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()               {}
func (*Metadata) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{7} }

func (m *Metadata) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Metadata) GetUniversityId() int64 {
	if m != nil {
		return m.UniversityId
	}
	return 0
}

func (m *Metadata) GetSubjectId() int64 {
	if m != nil {
		return m.SubjectId
	}
	return 0
}

func (m *Metadata) GetCourseId() int64 {
	if m != nil {
		return m.CourseId
	}
	return 0
}

func (m *Metadata) GetSectionId() int64 {
	if m != nil {
		return m.SectionId
	}
	return 0
}

func (m *Metadata) GetMeetingId() int64 {
	if m != nil {
		return m.MeetingId
	}
	return 0
}

func (m *Metadata) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Metadata) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

type Registration struct {
	Id               int64  `protobuf:"varint,1,opt,name=id" json:"id" db:"id"`
	UniversityId     int64  `protobuf:"varint,2,opt,name=university_id,json=universityId" json:"university_id" db:"university_id"`
	Period           string `protobuf:"bytes,3,opt,name=period" json:"period" db:"period"`
	PeriodDate       int64  `protobuf:"varint,4,opt,name=period_date,json=periodDate" json:"period_date" db:"period_date"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Registration) Reset()                    { *m = Registration{} }
func (m *Registration) String() string            { return proto.CompactTextString(m) }
func (*Registration) ProtoMessage()               {}
func (*Registration) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{8} }

func (m *Registration) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Registration) GetUniversityId() int64 {
	if m != nil {
		return m.UniversityId
	}
	return 0
}

func (m *Registration) GetPeriod() string {
	if m != nil {
		return m.Period
	}
	return ""
}

func (m *Registration) GetPeriodDate() int64 {
	if m != nil {
		return m.PeriodDate
	}
	return 0
}

type Semester struct {
	Year             int32  `protobuf:"varint,1,opt,name=year" json:"year"`
	Season           Season `protobuf:"varint,2,opt,name=season,enum=common.Season" json:"season"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Semester) Reset()                    { *m = Semester{} }
func (m *Semester) String() string            { return proto.CompactTextString(m) }
func (*Semester) ProtoMessage()               {}
func (*Semester) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{9} }

func (m *Semester) GetYear() int32 {
	if m != nil {
		return m.Year
	}
	return 0
}

func (m *Semester) GetSeason() Season {
	if m != nil {
		return m.Season
	}
	return Season_fall
}

func init() {
	proto.RegisterType((*University)(nil), "common.University")
	proto.RegisterType((*Subject)(nil), "common.Subject")
	proto.RegisterType((*Course)(nil), "common.Course")
	proto.RegisterType((*Section)(nil), "common.Section")
	proto.RegisterType((*Meeting)(nil), "common.Meeting")
	proto.RegisterType((*Instructor)(nil), "common.Instructor")
	proto.RegisterType((*Book)(nil), "common.Book")
	proto.RegisterType((*Metadata)(nil), "common.Metadata")
	proto.RegisterType((*Registration)(nil), "common.Registration")
	proto.RegisterType((*Semester)(nil), "common.Semester")
	proto.RegisterEnum("common.Season", Season_name, Season_value)
}
func (m *University) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *University) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintModel(data, i, uint64(m.Id))
	data[i] = 0x12
	i++
	i = encodeVarintModel(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	data[i] = 0x1a
	i++
	i = encodeVarintModel(data, i, uint64(len(m.Abbr)))
	i += copy(data[i:], m.Abbr)
	data[i] = 0x22
	i++
	i = encodeVarintModel(data, i, uint64(len(m.HomePage)))
	i += copy(data[i:], m.HomePage)
	data[i] = 0x2a
	i++
	i = encodeVarintModel(data, i, uint64(len(m.RegistrationPage)))
	i += copy(data[i:], m.RegistrationPage)
	data[i] = 0x32
	i++
	i = encodeVarintModel(data, i, uint64(len(m.MainColor)))
	i += copy(data[i:], m.MainColor)
	data[i] = 0x3a
	i++
	i = encodeVarintModel(data, i, uint64(len(m.AccentColor)))
	i += copy(data[i:], m.AccentColor)
	data[i] = 0x42
	i++
	i = encodeVarintModel(data, i, uint64(len(m.TopicName)))
	i += copy(data[i:], m.TopicName)
	if len(m.Subjects) > 0 {
		for _, msg := range m.Subjects {
			data[i] = 0x4a
			i++
			i = encodeVarintModel(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AvailableSemesters) > 0 {
		for _, msg := range m.AvailableSemesters {
			data[i] = 0x52
			i++
			i = encodeVarintModel(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Registrations) > 0 {
		for _, msg := range m.Registrations {
			data[i] = 0x5a
			i++
			i = encodeVarintModel(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Metadata) > 0 {
		for _, msg := range m.Metadata {
			data[i] = 0x62
			i++
			i = encodeVarintModel(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Subject) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Subject) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintModel(data, i, uint64(m.Id))
	data[i] = 0x10
	i++
	i = encodeVarintModel(data, i, uint64(m.UniversityId))
	data[i] = 0x1a
	i++
	i = encodeVarintModel(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	data[i] = 0x22
	i++
	i = encodeVarintModel(data, i, uint64(len(m.Number)))
	i += copy(data[i:], m.Number)
	data[i] = 0x2a
	i++
	i = encodeVarintModel(data, i, uint64(len(m.Season)))
	i += copy(data[i:], m.Season)
	data[i] = 0x32
	i++
	i = encodeVarintModel(data, i, uint64(len(m.Year)))
	i += copy(data[i:], m.Year)
	data[i] = 0x3a
	i++
	i = encodeVarintModel(data, i, uint64(len(m.Hash)))
	i += copy(data[i:], m.Hash)
	data[i] = 0x42
	i++
	i = encodeVarintModel(data, i, uint64(len(m.TopicName)))
	i += copy(data[i:], m.TopicName)
	if len(m.Courses) > 0 {
		for _, msg := range m.Courses {
			data[i] = 0x4a
			i++
			i = encodeVarintModel(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Metadata) > 0 {
		for _, msg := range m.Metadata {
			data[i] = 0x52
			i++
			i = encodeVarintModel(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Course) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Course) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintModel(data, i, uint64(m.Id))
	data[i] = 0x10
	i++
	i = encodeVarintModel(data, i, uint64(m.SubjectId))
	data[i] = 0x1a
	i++
	i = encodeVarintModel(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	data[i] = 0x22
	i++
	i = encodeVarintModel(data, i, uint64(len(m.Number)))
	i += copy(data[i:], m.Number)
	if m.Synopsis != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintModel(data, i, uint64(len(*m.Synopsis)))
		i += copy(data[i:], *m.Synopsis)
	}
	data[i] = 0x32
	i++
	i = encodeVarintModel(data, i, uint64(len(m.Hash)))
	i += copy(data[i:], m.Hash)
	data[i] = 0x3a
	i++
	i = encodeVarintModel(data, i, uint64(len(m.TopicName)))
	i += copy(data[i:], m.TopicName)
	if len(m.Sections) > 0 {
		for _, msg := range m.Sections {
			data[i] = 0x4a
			i++
			i = encodeVarintModel(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Metadata) > 0 {
		for _, msg := range m.Metadata {
			data[i] = 0x52
			i++
			i = encodeVarintModel(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Section) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Section) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintModel(data, i, uint64(m.Id))
	data[i] = 0x10
	i++
	i = encodeVarintModel(data, i, uint64(m.CourseId))
	data[i] = 0x1a
	i++
	i = encodeVarintModel(data, i, uint64(len(m.Number)))
	i += copy(data[i:], m.Number)
	data[i] = 0x22
	i++
	i = encodeVarintModel(data, i, uint64(len(m.CallNumber)))
	i += copy(data[i:], m.CallNumber)
	data[i] = 0x28
	i++
	i = encodeVarintModel(data, i, uint64(m.Max))
	data[i] = 0x30
	i++
	i = encodeVarintModel(data, i, uint64(m.Now))
	data[i] = 0x3a
	i++
	i = encodeVarintModel(data, i, uint64(len(m.Status)))
	i += copy(data[i:], m.Status)
	data[i] = 0x42
	i++
	i = encodeVarintModel(data, i, uint64(len(m.Credits)))
	i += copy(data[i:], m.Credits)
	data[i] = 0x4a
	i++
	i = encodeVarintModel(data, i, uint64(len(m.TopicName)))
	i += copy(data[i:], m.TopicName)
	if len(m.Meetings) > 0 {
		for _, msg := range m.Meetings {
			data[i] = 0x52
			i++
			i = encodeVarintModel(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Instructors) > 0 {
		for _, msg := range m.Instructors {
			data[i] = 0x5a
			i++
			i = encodeVarintModel(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Books) > 0 {
		for _, msg := range m.Books {
			data[i] = 0x62
			i++
			i = encodeVarintModel(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Metadata) > 0 {
		for _, msg := range m.Metadata {
			data[i] = 0x6a
			i++
			i = encodeVarintModel(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Meeting) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Meeting) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintModel(data, i, uint64(m.Id))
	data[i] = 0x10
	i++
	i = encodeVarintModel(data, i, uint64(m.SectionId))
	if m.Room != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintModel(data, i, uint64(len(*m.Room)))
		i += copy(data[i:], *m.Room)
	}
	if m.Day != nil {
		data[i] = 0x22
		i++
		i = encodeVarintModel(data, i, uint64(len(*m.Day)))
		i += copy(data[i:], *m.Day)
	}
	data[i] = 0x2a
	i++
	i = encodeVarintModel(data, i, uint64(len(m.StartTime)))
	i += copy(data[i:], m.StartTime)
	data[i] = 0x32
	i++
	i = encodeVarintModel(data, i, uint64(len(m.EndTime)))
	i += copy(data[i:], m.EndTime)
	data[i] = 0x3a
	i++
	i = encodeVarintModel(data, i, uint64(len(m.Index)))
	i += copy(data[i:], m.Index)
	if len(m.Metadata) > 0 {
		for _, msg := range m.Metadata {
			data[i] = 0x42
			i++
			i = encodeVarintModel(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Instructor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Instructor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintModel(data, i, uint64(m.Id))
	data[i] = 0x10
	i++
	i = encodeVarintModel(data, i, uint64(m.SectionId))
	data[i] = 0x1a
	i++
	i = encodeVarintModel(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Book) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Book) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintModel(data, i, uint64(m.Id))
	data[i] = 0x10
	i++
	i = encodeVarintModel(data, i, uint64(m.SectionId))
	data[i] = 0x1a
	i++
	i = encodeVarintModel(data, i, uint64(len(m.Title)))
	i += copy(data[i:], m.Title)
	data[i] = 0x22
	i++
	i = encodeVarintModel(data, i, uint64(len(m.Url)))
	i += copy(data[i:], m.Url)
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Metadata) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Metadata) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintModel(data, i, uint64(m.Id))
	data[i] = 0x10
	i++
	i = encodeVarintModel(data, i, uint64(m.UniversityId))
	data[i] = 0x18
	i++
	i = encodeVarintModel(data, i, uint64(m.SubjectId))
	data[i] = 0x20
	i++
	i = encodeVarintModel(data, i, uint64(m.CourseId))
	data[i] = 0x28
	i++
	i = encodeVarintModel(data, i, uint64(m.SectionId))
	data[i] = 0x30
	i++
	i = encodeVarintModel(data, i, uint64(m.MeetingId))
	data[i] = 0x3a
	i++
	i = encodeVarintModel(data, i, uint64(len(m.Title)))
	i += copy(data[i:], m.Title)
	data[i] = 0x42
	i++
	i = encodeVarintModel(data, i, uint64(len(m.Content)))
	i += copy(data[i:], m.Content)
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Registration) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Registration) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintModel(data, i, uint64(m.Id))
	data[i] = 0x10
	i++
	i = encodeVarintModel(data, i, uint64(m.UniversityId))
	data[i] = 0x1a
	i++
	i = encodeVarintModel(data, i, uint64(len(m.Period)))
	i += copy(data[i:], m.Period)
	data[i] = 0x20
	i++
	i = encodeVarintModel(data, i, uint64(m.PeriodDate))
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Semester) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Semester) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintModel(data, i, uint64(m.Year))
	data[i] = 0x10
	i++
	i = encodeVarintModel(data, i, uint64(m.Season))
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeFixed64Model(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Model(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintModel(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *University) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovModel(uint64(m.Id))
	l = len(m.Name)
	n += 1 + l + sovModel(uint64(l))
	l = len(m.Abbr)
	n += 1 + l + sovModel(uint64(l))
	l = len(m.HomePage)
	n += 1 + l + sovModel(uint64(l))
	l = len(m.RegistrationPage)
	n += 1 + l + sovModel(uint64(l))
	l = len(m.MainColor)
	n += 1 + l + sovModel(uint64(l))
	l = len(m.AccentColor)
	n += 1 + l + sovModel(uint64(l))
	l = len(m.TopicName)
	n += 1 + l + sovModel(uint64(l))
	if len(m.Subjects) > 0 {
		for _, e := range m.Subjects {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if len(m.AvailableSemesters) > 0 {
		for _, e := range m.AvailableSemesters {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if len(m.Registrations) > 0 {
		for _, e := range m.Registrations {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if len(m.Metadata) > 0 {
		for _, e := range m.Metadata {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Subject) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovModel(uint64(m.Id))
	n += 1 + sovModel(uint64(m.UniversityId))
	l = len(m.Name)
	n += 1 + l + sovModel(uint64(l))
	l = len(m.Number)
	n += 1 + l + sovModel(uint64(l))
	l = len(m.Season)
	n += 1 + l + sovModel(uint64(l))
	l = len(m.Year)
	n += 1 + l + sovModel(uint64(l))
	l = len(m.Hash)
	n += 1 + l + sovModel(uint64(l))
	l = len(m.TopicName)
	n += 1 + l + sovModel(uint64(l))
	if len(m.Courses) > 0 {
		for _, e := range m.Courses {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if len(m.Metadata) > 0 {
		for _, e := range m.Metadata {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Course) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovModel(uint64(m.Id))
	n += 1 + sovModel(uint64(m.SubjectId))
	l = len(m.Name)
	n += 1 + l + sovModel(uint64(l))
	l = len(m.Number)
	n += 1 + l + sovModel(uint64(l))
	if m.Synopsis != nil {
		l = len(*m.Synopsis)
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Hash)
	n += 1 + l + sovModel(uint64(l))
	l = len(m.TopicName)
	n += 1 + l + sovModel(uint64(l))
	if len(m.Sections) > 0 {
		for _, e := range m.Sections {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if len(m.Metadata) > 0 {
		for _, e := range m.Metadata {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Section) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovModel(uint64(m.Id))
	n += 1 + sovModel(uint64(m.CourseId))
	l = len(m.Number)
	n += 1 + l + sovModel(uint64(l))
	l = len(m.CallNumber)
	n += 1 + l + sovModel(uint64(l))
	n += 1 + sovModel(uint64(m.Max))
	n += 1 + sovModel(uint64(m.Now))
	l = len(m.Status)
	n += 1 + l + sovModel(uint64(l))
	l = len(m.Credits)
	n += 1 + l + sovModel(uint64(l))
	l = len(m.TopicName)
	n += 1 + l + sovModel(uint64(l))
	if len(m.Meetings) > 0 {
		for _, e := range m.Meetings {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if len(m.Instructors) > 0 {
		for _, e := range m.Instructors {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if len(m.Books) > 0 {
		for _, e := range m.Books {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if len(m.Metadata) > 0 {
		for _, e := range m.Metadata {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Meeting) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovModel(uint64(m.Id))
	n += 1 + sovModel(uint64(m.SectionId))
	if m.Room != nil {
		l = len(*m.Room)
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Day != nil {
		l = len(*m.Day)
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.StartTime)
	n += 1 + l + sovModel(uint64(l))
	l = len(m.EndTime)
	n += 1 + l + sovModel(uint64(l))
	l = len(m.Index)
	n += 1 + l + sovModel(uint64(l))
	if len(m.Metadata) > 0 {
		for _, e := range m.Metadata {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Instructor) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovModel(uint64(m.Id))
	n += 1 + sovModel(uint64(m.SectionId))
	l = len(m.Name)
	n += 1 + l + sovModel(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Book) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovModel(uint64(m.Id))
	n += 1 + sovModel(uint64(m.SectionId))
	l = len(m.Title)
	n += 1 + l + sovModel(uint64(l))
	l = len(m.Url)
	n += 1 + l + sovModel(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Metadata) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovModel(uint64(m.Id))
	n += 1 + sovModel(uint64(m.UniversityId))
	n += 1 + sovModel(uint64(m.SubjectId))
	n += 1 + sovModel(uint64(m.CourseId))
	n += 1 + sovModel(uint64(m.SectionId))
	n += 1 + sovModel(uint64(m.MeetingId))
	l = len(m.Title)
	n += 1 + l + sovModel(uint64(l))
	l = len(m.Content)
	n += 1 + l + sovModel(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Registration) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovModel(uint64(m.Id))
	n += 1 + sovModel(uint64(m.UniversityId))
	l = len(m.Period)
	n += 1 + l + sovModel(uint64(l))
	n += 1 + sovModel(uint64(m.PeriodDate))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Semester) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovModel(uint64(m.Year))
	n += 1 + sovModel(uint64(m.Season))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovModel(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozModel(x uint64) (n int) {
	return sovModel(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *University) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: University: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: University: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abbr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Abbr = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomePage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomePage = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistrationPage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegistrationPage = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MainColor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MainColor = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccentColor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccentColor = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subjects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subjects = append(m.Subjects, Subject{})
			if err := m.Subjects[len(m.Subjects)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableSemesters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailableSemesters = append(m.AvailableSemesters, Semester{})
			if err := m.AvailableSemesters[len(m.AvailableSemesters)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Registrations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Registrations = append(m.Registrations, Registration{})
			if err := m.Registrations[len(m.Registrations)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata, Metadata{})
			if err := m.Metadata[len(m.Metadata)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subject) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniversityId", wireType)
			}
			m.UniversityId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UniversityId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Number = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Season", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Season = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Year", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Year = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Courses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Courses = append(m.Courses, Course{})
			if err := m.Courses[len(m.Courses)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata, Metadata{})
			if err := m.Metadata[len(m.Metadata)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Course) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Course: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Course: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubjectId", wireType)
			}
			m.SubjectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SubjectId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Number = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Synopsis", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Synopsis = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sections = append(m.Sections, Section{})
			if err := m.Sections[len(m.Sections)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata, Metadata{})
			if err := m.Metadata[len(m.Metadata)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Section) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Section: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Section: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CourseId", wireType)
			}
			m.CourseId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CourseId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Number = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallNumber = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			m.Max = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Max |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Now", wireType)
			}
			m.Now = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Now |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credits", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credits = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meetings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Meetings = append(m.Meetings, Meeting{})
			if err := m.Meetings[len(m.Meetings)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instructors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instructors = append(m.Instructors, Instructor{})
			if err := m.Instructors[len(m.Instructors)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Books", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Books = append(m.Books, Book{})
			if err := m.Books[len(m.Books)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata, Metadata{})
			if err := m.Metadata[len(m.Metadata)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Meeting) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Meeting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Meeting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectionId", wireType)
			}
			m.SectionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SectionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Room", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Room = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Day", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Day = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata, Metadata{})
			if err := m.Metadata[len(m.Metadata)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Instructor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Instructor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Instructor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectionId", wireType)
			}
			m.SectionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SectionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Book) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Book: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Book: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectionId", wireType)
			}
			m.SectionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SectionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metadata) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniversityId", wireType)
			}
			m.UniversityId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UniversityId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubjectId", wireType)
			}
			m.SubjectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SubjectId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CourseId", wireType)
			}
			m.CourseId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CourseId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SectionId", wireType)
			}
			m.SectionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SectionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeetingId", wireType)
			}
			m.MeetingId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MeetingId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Registration) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Registration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Registration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniversityId", wireType)
			}
			m.UniversityId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UniversityId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Period", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Period = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodDate", wireType)
			}
			m.PeriodDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PeriodDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Semester) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Semester: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Semester: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Year", wireType)
			}
			m.Year = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Year |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Season", wireType)
			}
			m.Season = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Season |= (Season(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModel(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModel
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthModel
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowModel
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipModel(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthModel = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModel   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorModel = []byte{
	// 1151 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xbc, 0x57, 0xcd, 0x6e, 0x1c, 0x45,
	0x10, 0xce, 0x7a, 0xd6, 0xfb, 0x53, 0xbb, 0xb6, 0xd7, 0x9d, 0x10, 0x86, 0x1c, 0xec, 0x30, 0x12,
	0x92, 0xc5, 0x8f, 0x81, 0x20, 0x45, 0x22, 0x42, 0x02, 0x39, 0x48, 0x28, 0x42, 0x44, 0x68, 0x02,
	0x17, 0x2e, 0xab, 0xd9, 0x9d, 0xc6, 0x1e, 0xd8, 0x99, 0x5e, 0xcd, 0xf4, 0x26, 0xf6, 0x3b, 0xf0,
	0x0a, 0x9c, 0xb8, 0x21, 0xf1, 0x1e, 0x1c, 0x39, 0x21, 0x4e, 0x11, 0xe2, 0xce, 0x01, 0x9e, 0x80,
	0xaa, 0xee, 0xea, 0x99, 0x6d, 0x3b, 0x64, 0xd7, 0x91, 0x9c, 0x83, 0x77, 0xba, 0xab, 0xbe, 0xea,
	0x9f, 0xfa, 0xbe, 0xae, 0x6e, 0x83, 0x98, 0xaa, 0x3c, 0x57, 0xc5, 0xbb, 0xb9, 0x4a, 0xe5, 0xec,
	0x70, 0x5e, 0x2a, 0xad, 0x44, 0xc7, 0xda, 0x6e, 0xc1, 0xb1, 0x3a, 0x56, 0xd6, 0x16, 0xfd, 0xb8,
	0x09, 0xf0, 0x75, 0x91, 0x3d, 0x96, 0x65, 0x95, 0xe9, 0x33, 0xb1, 0x0f, 0x1b, 0x59, 0x1a, 0xb6,
	0x6e, 0xb7, 0x0e, 0x82, 0xa3, 0x9d, 0x5f, 0x9f, 0xee, 0x5f, 0xfb, 0xf7, 0xe9, 0x7e, 0x37, 0x9d,
	0xdc, 0x8b, 0xb2, 0x34, 0x8a, 0xd1, 0x25, 0xde, 0x80, 0x76, 0x91, 0xe4, 0x32, 0xdc, 0x40, 0x48,
	0xff, 0x68, 0x97, 0x21, 0x7d, 0x82, 0x90, 0x3d, 0x8a, 0x8d, 0x9b, 0x60, 0xc9, 0x64, 0x52, 0x86,
	0xc1, 0x45, 0x18, 0xd9, 0x11, 0x46, 0x1f, 0xf1, 0x01, 0xf4, 0x4f, 0x54, 0x2e, 0xc7, 0xf3, 0xe4,
	0x58, 0x86, 0x6d, 0x83, 0xbd, 0xc9, 0xd8, 0x6d, 0xc2, 0xd6, 0xce, 0x28, 0xee, 0x51, 0xfb, 0x4b,
	0x6c, 0x8a, 0xcf, 0x61, 0xb7, 0x94, 0xc7, 0x59, 0xa5, 0xcb, 0x44, 0x67, 0xaa, 0xb0, 0xc1, 0x9b,
	0x26, 0x78, 0x8f, 0x83, 0x6f, 0x52, 0xf0, 0x05, 0x50, 0x14, 0x8f, 0x96, 0x6d, 0x66, 0xb0, 0xbb,
	0x00, 0x79, 0x92, 0x15, 0xe3, 0xa9, 0x9a, 0xa9, 0x32, 0xec, 0x98, 0x51, 0x5e, 0xe5, 0x51, 0x76,
	0x68, 0x94, 0xc6, 0x1b, 0xc5, 0x7d, 0xea, 0xdc, 0xa7, 0xb6, 0xf8, 0x08, 0x86, 0xc9, 0x74, 0x2a,
	0x0b, 0xcd, 0x91, 0x5d, 0x13, 0xf9, 0x1a, 0x47, 0xee, 0x9a, 0x8d, 0x2e, 0xf9, 0xa3, 0x78, 0x60,
	0xbb, 0x36, 0x1a, 0x67, 0xd5, 0x6a, 0x9e, 0x4d, 0xc7, 0x26, 0x97, 0xbd, 0x8b, 0xb3, 0x36, 0x5e,
	0x9c, 0xd5, 0x74, 0x1e, 0x52, 0x5a, 0xdf, 0x87, 0x5e, 0xb5, 0x98, 0x7c, 0x27, 0xa7, 0xba, 0x0a,
	0xfb, 0xb7, 0x83, 0x83, 0xc1, 0x9d, 0x9d, 0x43, 0x4b, 0xea, 0xe1, 0x23, 0x6b, 0x3f, 0x6a, 0xd3,
	0x30, 0x71, 0x0d, 0x13, 0x9f, 0xc1, 0xf5, 0xe4, 0x71, 0x92, 0xcd, 0x92, 0xc9, 0x4c, 0x8e, 0x2b,
	0x99, 0xcb, 0x4a, 0x23, 0xd7, 0x21, 0x98, 0xe8, 0x51, 0x1d, 0xcd, 0x0e, 0x0e, 0x17, 0x75, 0x88,
	0x73, 0x54, 0xe2, 0x13, 0xd8, 0x5a, 0xce, 0x5e, 0x15, 0x0e, 0xcc, 0x10, 0x37, 0xdc, 0x10, 0xf1,
	0x92, 0x93, 0x87, 0xf1, 0x03, 0xc4, 0x1d, 0xe8, 0xe5, 0x52, 0x27, 0x69, 0xa2, 0x93, 0x70, 0xe8,
	0xcf, 0xff, 0x05, 0xdb, 0xdd, 0xf2, 0x1d, 0x2e, 0xfa, 0x3d, 0x80, 0x2e, 0x6f, 0x6d, 0xb5, 0x38,
	0x3f, 0x86, 0xad, 0x45, 0xad, 0xe5, 0x31, 0x62, 0x37, 0x0c, 0xf6, 0x16, 0x63, 0x05, 0x61, 0x3d,
	0x40, 0x14, 0x0f, 0x9b, 0xfe, 0x83, 0x46, 0xdd, 0xc1, 0xf3, 0xd5, 0xfd, 0x16, 0x74, 0x8a, 0x45,
	0x3e, 0x91, 0x25, 0x6b, 0xf6, 0x3a, 0x03, 0x07, 0x06, 0x68, 0x3c, 0x51, 0xcc, 0x10, 0x02, 0x57,
	0x32, 0xa9, 0x54, 0xc1, 0x1a, 0xf5, 0xc0, 0xd6, 0x83, 0x60, 0xdb, 0xa0, 0x05, 0x9c, 0xc9, 0xc4,
	0x09, 0xd1, 0x5b, 0x00, 0xd9, 0x71, 0x01, 0xf4, 0x21, 0xd8, 0x49, 0x52, 0x9d, 0xb0, 0xea, 0x3c,
	0x18, 0xd9, 0x11, 0x46, 0x9f, 0x17, 0x96, 0xd9, 0x21, 0x74, 0xa7, 0x6a, 0x51, 0x56, 0xd2, 0xa9,
	0x6c, 0xdb, 0xf1, 0x74, 0xdf, 0x98, 0x99, 0x25, 0x07, 0xf2, 0x88, 0x85, 0x35, 0x89, 0xfd, 0x39,
	0x80, 0x8e, 0x1d, 0x6d, 0x35, 0xaf, 0xb8, 0x0f, 0xd6, 0x73, 0x43, 0xaa, 0xb7, 0x8f, 0xc6, 0x8b,
	0xfb, 0xe0, 0xce, 0x15, 0xd1, 0xf9, 0x0e, 0x1e, 0xc1, 0xb3, 0x42, 0xcd, 0xab, 0xac, 0x62, 0x42,
	0x77, 0x11, 0xba, 0x65, 0x56, 0xc1, 0x76, 0x2c, 0x56, 0xae, 0x59, 0x33, 0xd5, 0xb9, 0x0c, 0x53,
	0xdd, 0x4b, 0x15, 0x04, 0xdc, 0xab, 0x39, 0x8f, 0xe7, 0x0b, 0x82, 0xb5, 0xd7, 0x05, 0x81, 0x61,
	0x2f, 0x44, 0xd6, 0x3f, 0x6d, 0x3c, 0x85, 0x76, 0x80, 0xd5, 0x6c, 0x61, 0x51, 0xb7, 0xc2, 0x68,
	0xc8, 0xf2, 0x8a, 0x7a, 0xed, 0xc4, 0x3c, 0xd9, 0x36, 0x52, 0xd5, 0x70, 0x10, 0xac, 0xe6, 0xe0,
	0x43, 0x18, 0x4c, 0x93, 0xd9, 0x6c, 0xec, 0xb1, 0x16, 0x72, 0xc4, 0xc8, 0xcc, 0xd1, 0xb8, 0xa3,
	0x18, 0xa8, 0xf7, 0xd0, 0x86, 0x46, 0x10, 0xe4, 0xc9, 0xa9, 0x61, 0x2e, 0x38, 0x1a, 0x71, 0x48,
	0xcf, 0x16, 0xfa, 0xd3, 0x28, 0x26, 0x27, 0x61, 0x0a, 0xf5, 0xc4, 0x50, 0x76, 0x0e, 0x83, 0x66,
	0xc4, 0xe0, 0xaf, 0x39, 0xd5, 0x3a, 0xd1, 0x8b, 0x8a, 0xc9, 0xf2, 0x4f, 0xb5, 0xf1, 0xd0, 0xa9,
	0x36, 0x0d, 0x73, 0x9e, 0x4a, 0x99, 0x66, 0x58, 0xb5, 0xed, 0x21, 0xbc, 0xc1, 0xe8, 0xa1, 0x59,
	0xab, 0x75, 0x45, 0xb1, 0x03, 0x9d, 0x53, 0x43, 0xff, 0x32, 0x6a, 0xc8, 0xa5, 0xd4, 0x59, 0x71,
	0xec, 0x0a, 0xfc, 0x4e, 0x43, 0xad, 0xb1, 0x37, 0xcc, 0x5a, 0x98, 0xb8, 0x07, 0x83, 0xac, 0xc0,
	0x12, 0xbd, 0x98, 0x6a, 0x55, 0xba, 0x9a, 0x2e, 0x5c, 0xd4, 0x83, 0xda, 0xc5, 0x81, 0xcb, 0x60,
	0x71, 0x00, 0x9b, 0x13, 0xa5, 0xbe, 0xaf, 0xb8, 0x98, 0x0f, 0x5d, 0xd4, 0x11, 0x1a, 0x19, 0x6f,
	0x01, 0x9e, 0xe6, 0xb6, 0xd6, 0xd4, 0xdc, 0xdf, 0x1b, 0xd0, 0xe5, 0x55, 0xaf, 0x57, 0x21, 0xac,
	0x3e, 0xff, 0xaf, 0x42, 0xd4, 0x5e, 0xaa, 0x10, 0xb6, 0x83, 0xb2, 0x7b, 0x1d, 0xda, 0xa5, 0x52,
	0x39, 0x8b, 0x6e, 0xcb, 0x1d, 0x4d, 0xb2, 0xe1, 0xd1, 0xa4, 0x8f, 0xd8, 0x83, 0x20, 0x4d, 0xce,
	0x58, 0x64, 0x43, 0xa7, 0x04, 0x34, 0xa1, 0x12, 0xf0, 0xd7, 0x4c, 0xad, 0x93, 0x52, 0x8f, 0x75,
	0x96, 0xbb, 0x77, 0x88, 0x3f, 0x75, 0xed, 0xa5, 0xa9, 0xa9, 0xf3, 0x15, 0xb6, 0xc5, 0x7b, 0xd0,
	0x93, 0x45, 0x6a, 0xa3, 0x6c, 0x75, 0x78, 0x85, 0xa3, 0x4c, 0x31, 0x71, 0x3e, 0x94, 0x05, 0x36,
	0x4d, 0x04, 0xe6, 0x3b, 0x2b, 0x52, 0x79, 0xca, 0x92, 0x13, 0x0c, 0x07, 0x93, 0x08, 0x72, 0x44,
	0xb1, 0x05, 0x78, 0xf9, 0xee, 0xad, 0x99, 0xef, 0x1f, 0x5a, 0x00, 0x0d, 0xdf, 0x57, 0x97, 0xf2,
	0xf5, 0x8a, 0x72, 0xf4, 0x4b, 0x0b, 0xda, 0x24, 0xa4, 0xab, 0x5b, 0x08, 0xa6, 0x53, 0x67, 0x7a,
	0xe6, 0x56, 0xe2, 0xa5, 0xd3, 0x38, 0x30, 0x9d, 0xe6, 0x4b, 0x05, 0x61, 0x51, 0xce, 0x58, 0x02,
	0x5e, 0x41, 0x40, 0x33, 0xca, 0x80, 0x7e, 0x7f, 0x0a, 0xa0, 0xe7, 0x72, 0xfb, 0x12, 0x5e, 0x2a,
	0xfe, 0x95, 0x18, 0xac, 0x7d, 0x25, 0x7a, 0xc5, 0xb9, 0xbd, 0x66, 0x71, 0xf6, 0x33, 0xbc, 0xb9,
	0x76, 0x86, 0xe9, 0x71, 0x6d, 0x4f, 0x30, 0xc5, 0x75, 0x2e, 0xc6, 0x35, 0x5e, 0x7a, 0x5c, 0xdb,
	0xce, 0x32, 0x33, 0xdd, 0x55, 0xcc, 0x98, 0x97, 0x4a, 0xa1, 0xf1, 0x61, 0xfd, 0xcc, 0xca, 0x6a,
	0x5d, 0x54, 0x59, 0xb9, 0xf5, 0x47, 0x0b, 0x86, 0xcb, 0x0f, 0xd5, 0x97, 0xc0, 0x14, 0xde, 0x14,
	0x73, 0x59, 0x66, 0x2a, 0x7d, 0xd6, 0xcd, 0x66, 0x3d, 0x78, 0x53, 0xd8, 0x06, 0xdd, 0x6c, 0xb6,
	0x35, 0x46, 0x1d, 0x49, 0x26, 0xc8, 0xbb, 0xd9, 0x96, 0xdc, 0x78, 0xb3, 0xd9, 0xde, 0xa7, 0xb6,
	0xd3, 0x73, 0x8f, 0x75, 0x11, 0xf2, 0x33, 0x92, 0xf6, 0xb5, 0xc9, 0x27, 0xdd, 0xbe, 0x1c, 0xdf,
	0xae, 0x5f, 0xa3, 0xb4, 0x8f, 0xed, 0xe6, 0x65, 0xf7, 0xc8, 0x58, 0x19, 0xcb, 0x98, 0x37, 0xef,
	0x42, 0xc7, 0xda, 0x45, 0x0f, 0xda, 0xdf, 0xe2, 0x2d, 0x3a, 0xba, 0x26, 0x00, 0x47, 0x98, 0x97,
	0x48, 0xd4, 0xa8, 0x65, 0xda, 0x8b, 0x3c, 0x97, 0xe5, 0x68, 0x83, 0xda, 0x4f, 0x32, 0xcc, 0x72,
	0x39, 0x0a, 0x90, 0x85, 0xbf, 0xf6, 0x5a, 0xbf, 0xe1, 0xdf, 0x9f, 0xf8, 0xf7, 0x0d, 0xff, 0xdf,
	0xf9, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xee, 0x95, 0xfb, 0x1f, 0x94, 0x0e, 0x00, 0x00,
}
